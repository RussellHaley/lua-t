lua-t => An extension of the Lua Language
======================================================

Overview
++++++++

What is it
----------

lua-t is a library which extends Lua by various functionality.  I aims to be
very object oriented and in itself coherent using the same pattern of OOP in all
places offering a usable API.  It follows the Lua guidelines for OOP.  lua-t is
less of a system library than it is an extension which get's compiled into a
static Lua executable for a self contained application.  It covers some areas
which are already served by other libraries such as lua-socket, however, it aims
to bring functionality together under one umbrella and provide a framework to
imlpement more C based functionality with less overhead.  This makes programming
easier on the Lua side of things as it makes for a very consistent way to code.



Contents (High level overview)
-----------------------------

 - Networking (t.Socket)  --> TCP,UDP etc
 - Buffers (t.Buffer)     --> a buffer of defined length with mutable values
 - Packers (t.Pack)       --> a Packer of type and size
 - Struct (t.Pack.Struct) --> a Combination of Packers or Structs
 - Array (t.Pack.Struct)  --> a Sequence of Packers or Structs of same type
 - Encoding (t.Encoding)  --> En/Decoding/ En/Decryption, Hashes etc.
 - Unit Tests (t.Test)    --> comprehensive tests with unified output
 - Asynchronous (t.Loop)  --> event/select based asynchronous workings



Coding Standards
+++++++++++++++

OOP interface
-------------

lua-t uses a unified OOP type according to Luas own recomendation for objects.
Class.new() or Class() create new objects.  lua-t is, so far, exclusively
written in C.  The followng list provides an overview of naming conventions and
will help to navigate the source code a lot faster.


C-Class
-------

Prefixes:

 - t               --> part of the t library
 - t_abc           --> part of the t_abc class
 - lt_abc          --> exposed to the Lua API

t_abc... functions would be usually exposed to t_abc.h and such available
from other code that can interact with t_abc type variables.  Most lt_abc...
functions will remain static as they are accesed within the class only.


Exposure Level:

 - lt_abc_Func  --> t.Abc.Func()  static method on t.Abc (eg. t.Abc.New)
 - lt_abc__Func --> metatable function of t.Abc such as t.Abc() (__call method)
 - lt_abc_func  --> method of t.Abc instance such as myAbc:func() 
 - lt_abc__func --> metatable method of t.Abc instance (#myAbc length)

Example for a fictional abc class the way they are organized in lua-t:

struct t_abc { ..., ..., ...  };
   A struct defining the userdata generated by t.Abc(). This is typically defined
   in a file called t_abc.h

abc = t_abc_create_ud( L, sz):
   Create a userdata of type t.Abc with size sz and push onto stack, shall return
   a pointer to abc struct
abc = t_abc_check_ud( L, pos, check):
   Check element on stack pos for to be a userdata of type abc (t.Abc).  If
   check==1 hard fail otherwise fail soft and return NULL pointer.  If
   successful return pointer to abc struct.

lt_abc__Call( luaVM )
  t.Abc( p1, p2 ) styled constructor
lt_abc_New( luaVM )
  t.Abc.New( p1, p2 ) styled constructor
lt_abc_Flav1( luaVM )
  t.Abc.Flav1( p2 ) styled constructor
lt_abc_DoIt( luaVM )
  t.Abc.Doit( p2 ) static method

lt_abc_read( luaVM )
  abc:read( p ) instance method

lt_abc_write( luaVM )
  abc:write( p, 2 ) instance method


lt_abc__len( luaVM )
  return a meaningful #abc value

lt_abc__tostring( luaVM )
  returns string "t.Abc{p1:p2}: 0x123456"

lt_abc__gc( luaVM )
   clean up resources when abc gets collected




Documentation:
++++++++++++++

t.Pack
---------

A Packer is a simple Data Format definition containing size and type. The
following types are available:

 - xt.Packer.Bit(x,y)  = creates a packer of type Bit with big Endianess and
                         length x and offset y
 - xt.Packer.Int(x)    = creates a packer of type Int with native Endianess and
                         length x
 - xt.Packer.IntL(x)   = creates a packer of type Int with little Endianess and
                         length x
 - xt.Packer.IntB(x)   = creates a packer of type Int with Big Endianess and
                         length x
 - xt.Packer.Float(x)  = creates a packer of type Float with length x
 - xt.Packer.String(x) = creates a packer of type String with length x


xt.Pack.Struct
--------------

An ordered and optionally named collection of xt.Pack and/or xt.Pack.Struct. ::

   s = xt.Pack.Struct(
      { length       = xt.Pack.Int( 2 ) },
      { ['type']     = xt.Pack.Int( 2 ) },
      { ['@status']  = xt.Pack.Int( 1 ) },
      { ConsistCount = xt.Pack.Int( 1 ) },
      xt.Pack.String(17)
   )

Available methods on x.Pack.Struct s are:

   - pairs( s ) => iterator,    returns  name, xt.Pack.Reader
                   returns values in order!
   - __index    => xt.Pack.Reader, returns a type and position information
   - #struct    => length,      returns number of elements in struct
                   for i=1:#struct do allows numbered iteration (Lua 5.3 style)
   - tostring   => object name,
                   print(s) returns "xt.Pack.Struct(len,sz}: address
   - xt.Pack.size(s) => returns size of s in bytes


xt.Pack.Array
--------------

An ordered collection of a single xt.Pack or xt.Pack.Struct of n elements. ::

   s = xt.Pack.Array( xt.Pack.Int( 2 ), 24 )


Available methods on x.Pack.Struct s are:

   - pairs( s ) => iterator,    returns  name, xt.Pack.Reader
                   returns values in order!
   - #struct    => length,      returns number of elements in struct
                   for i=1:#struct do allows numbered iteration (Lua 5.3 style)
   - tostring   => object name,
                   print(s) returns "xt.Pack.Struct(len,sz}: address
   - xt.Pack.size(s) => returns size of s in bytes



xt.Pack.Reader
--------------

An xt.Pack or xt.Pack.Struct or xt.Pack.Array element returned by __index
method.  Additionally to the type of the element it also contains information
about the offset in the returning context. ::

   a = xt.Pack.String( 2 )
   s = xt.Pack.Struct (
      { one       = a},
      { two       = a},
      { three     = a},
      { four      = a}
   )
   b = "ZZYYXXWW"
   for k,v in pairs(s) do
      print( k, xt.Pack.read( v, b ) )
   end
   one        ZZ
   two        YY
   three      XX
   four       WW


